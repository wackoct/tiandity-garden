---
date created: 2022-10-04
date modified: 2022-10-16
---

### 事件与Effects分离

事件处理进程仅在您再次执行相同的交互时重新运行。与事件处理进程不同，如果效果读取的某个值（如 prop 或状态变量）与上次渲染期间的值不同，则效果会重新同步  
有时，您还希望混合使用这两种行为：一个效果，该效果会根据某些值重新运行，但不会响应其他值

- 事件处理进程中的逻辑不是反应式的。除非用户再次执行相同的交互（例如，单击），否则它不会再次运行。事件处理进程可以读取反应性值，但它们不会对其更改“做出反应”
- 效果内部的逻辑是被动的。如果效果读取反应性值，则必须将其指定为依赖项。然后，如果重新渲染导致该值发生变化，React 将使用新值再次重新运行效果的逻辑

**您可以将非反应性逻辑从 Effects 移到 Event 函数中。仅从 Effects 内部调用 Event 函数**  
不要将 Event 函数传递给其他组件或 Hooks

### 移除Effect依赖

当您编写效果时，Linter 将验证您是否已将效果读取的每个反应值（如道具和状态）包含在效果的依赖项列表中  
这可以确保您的 Effect 与组件的最新 props 和 state 保持同步

#### 依赖项应与代码匹配

#### 要删除依赖项，请证明它不是依赖项

反应式值包括 props 以及直接在组件内部声明的所有变量和函数

这就是您现在可以指定空 （[]） 依赖项列表的原因。你的效果真的不再依赖于任何反应性值，所以当任何组件的道具或状态发生变化时，它真的不需要重新运行

如果要更改依赖项，请先更改周围的代码  
您可以将依赖项列表视为 Effect 代码使用的所有反应式值的列表

移除不需要的依赖项，需要先解决的问题：

- 此代码是否应移动到事件处理进程？
- 你的效应是否在做一些不相关的事情？  
**每个效果都应表示一个独立的同步过程**
- 您是否正在阅读某些状态来计算下一个状态？
- 是否要读取值而不对其更改“做出反应”？
- 某些反应性值是否无意中发生变化？

如果要读取最新值而不“响应”它，请从效果中提取事件函数 （API提案）  
在 JavaScript 中，如果对象和函数是在不同的时间创建的，则认为它们是不同的  
尽量避免对象和函数依赖。将它们移到组件外部或效果内部
