---
date created: 2022-10-01
date modified: 2022-10-16
---

Effects 与组件具有不同的生命周期  
组件可以装载、更新或卸载  
Effects 只能执行两项操作：开始同步某些内容，稍后停止同步它

#### Effect的生命周期

每个React组件的生命周期

- 组件在添加到屏幕时，组件挂载
- 组件在接收新的props和状态时，组件更新。通常在响应交互时发生
- 组件从屏幕中删除时，组件卸载

这是考虑组件的好方法，但不是关于 Effects 的好方法  
**Effects 描述如何将外部系统与当前属性和状态同步**

##### 为什么同步可能需要多次发生

##### React 如何重新同步您的Effect

停止同步，调用清楚函数  
 React 将运行您在此渲染期间提供的Effect——同步新的状态

##### 从Effect的角度思考

始终专注于每次单个启动/停止周期。组件是挂载、更新还是卸载都无关紧要。您需要做的就是描述如何启动同步以及如何停止同步。如果你做得好，你的 Effect 将能够适应于根据需要多次启动和停止

##### React 如何验证您的Effect是否可以重新同步

React 通过强制您的 Effect 在开发中立即执行此操作来验证它是否可以重新同步

##### React 如何知道它需要重新同步Effect

显式地指定Effect依赖——当依赖改变，重新同步Effect  
每次重渲染之后，React会查看传入的依赖数组  
Object.is比对依赖项

##### 每个Effect表示一个单独的同步过程

依赖项与其内在逻辑应是相关的  
**代码中的每个Effect都应表示一个单独且独立的同步过程**

#### Effect对反应值有“反应”

在组件内声明的 props、state和其他值是反应式的，因为它们是在渲染期间计算的，并参与 React 数据流

##### 具有空依赖项的Effect意味着什幺

如果您从 Effect 的角度考虑，则根本不需要考虑安装和卸载。重要的是，您已经指定了 Effect 在启动和停止同步时执行的操作。  
它没有任何反应式的依赖性

##### 组件体中声明的所有变量都是反应式的

**组件内部的所有值（包括道具、状态和你组件主体中的变量）都是反应式的。任何反应性的值都可以在重新渲染时发生变化，所以你需要把反应性的值作为Effect的依赖项**

全局值或可变值是否可以是依赖项？  
**可变值（包括全局变量）不是反应性的**

##### React 验证您是否将每个反应式值指定为依赖关系

如果你的 linter 是为 React 配置的，它将检查你的 Effect 代码使用的每个反应式值是否都声明为其依赖项

##### 当您不想重新同步时该怎么办

您可以向 linter“证明”这些值不是反应性值，即它们不能因重新渲染而更改  
将它们移到组件之外  
也可以将它们移到Effect中，它们不是在渲染期间计算的，因此它们不是反应式的

**Effects 是反应式代码块**

您无法“选择”依赖项。您的依赖项必须包括您在效果中读取的每个反应式值

- 检查您的效果是否代表一个独立的同步过程
- 如果要读取道具或状态的最新值，而不对其“做出反应”并重新同步效果
- 避免依赖对象和函数作为依赖项
