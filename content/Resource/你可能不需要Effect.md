---
date created: 2022-09-29
date modified: 2022-10-01
---

Effect是React程序中的逃生舱  
它们允许您“走出”React，并将您的组件与一些外部系统同步

删除不必要的Effects将使代码更易于遵循，运行速度更快，并且不易出错

### 如何移除不必要的Effects

- 你不需要 Effects 来转换数据以进行渲染
- 你不需要 Effects 处理用户事件

### 基于props或state更新状态

当某些东西可以从现有的 props 或 state 中计算出来时，不要把它放在 state 中。相反，请在渲染期间计算它

### 缓存昂贵的计算

移除过滤处理的派生状态，直接计算结果，并用useMemo缓存结果

```js
import { useMemo, useState } from 'react';  

function TodoList({ todos, filter }) {  
	const [newTodo, setNewTodo] = useState('');  
	// ✅ Does not re-run getFilteredTodos() unless todos or filter change  
	const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);  
	// ...  
}
```

### 重置属性更改时的所有状态

### 在 Props 发生变化时调整某种状态

### 在事件处理进程之间共享逻辑

当您不确定某些代码应该在 Effect 中还是在事件处理程序中时，问问自己为什么需要运行此代码。仅将 Effects 用于应该运行的代码，因为该组件已显示给用户

### 发送POST请求

如果此逻辑是由特定交互引起的，请将其保留在事件处理进程中。如果是由用户在屏幕上看到该组件引起的，请将其保留在“效果”中

### 计算链

Effects 不应该相互耦合，避免构成计算链  
提取逻辑合并成函数，统一处理状态

### 初始化应用程序

如果某些逻辑必须为每个应用加载运行一次，而不是每个组件装载运行一次，则可以添加一个顶级变量来跟踪它是否已经执行，并始终跳过重新运行它

### 通知父组件有关状态更改的信息

“提升状态”允许父组件通过切换父组件自己的状态来完全控制切换。这意味着父组件必须包含更多逻辑，但需要担心的整体状态会更少。每当您尝试保持两个不同的状态变量同步时，尝试提升状态都是一个标志！

### 将数据传递给父级

在React中，数据流是从父级流向子级  
当子组件在 Effects 中更新其父组件的状态时，数据流将变得非常难以跟踪

### 订阅外部存储

### 获取数据

虽然此组件可见，但您希望根据当前页面和查询使结果与网络中的数据保持同步。这就是为什幺它是一种 Effect
虽然仅凭这一点并不像使用框架的内置数据获取机制那样有效，但将数据提取逻辑移动到自定义 Hook 中将使以后更容易采用高效的数据提取策略